
* cfd
This benchmark has been converted to SAC (euler3d.sac). The result of the SAC 
generated CUDA code has been compared with the orginal Rodina version and the SAC 
generated sequential code. The results match for most of the data, however, when
the result is too small, e.g. 10^(-17), the results from CUDA just shows 0 while
the result from the other two can still be displayed as some number to the power
of -17. This could be due to the difference in architectures but it has not
been investigated further.

 Currently we only have double versions, they are 
euler3d.sac, euler3d_cpu_double.cpp and euler3d_gpu_double.cu. Note that to 
better utilise the GPU off chip memory bandwidth, the major arrays in the program
has been transformed from row-wise to column-wise. For example, arrays "varaibles" 
and "fluxes" were orginally of shape [SIZE, NVAR]. In the Rodinia CUDA version,
they have been changed to shape [NVAR, SIZE]. The same change has also been
made in the SAC version. 

In the Rodinia CUDA version, the major kernel "compute_flux"
is invoked with a 1D thread grid along the X dimension. Each thread essentially
computes 5 different elements along the same column of array "fluxes"(Y dimension). 
These five elements are: density, momentum_x, momentum_y, momentum_z and density_engery.
This organization ensure coalesced off chip memory accesses. However, with WITH-loop
in SAC, this is difficult to achieve. Because WITH-loop does not allow the inner
dimension of an array to computed in parallel. So the current implmentation we 
have is WITH-loop with 5 partions. Essentially, each partition computes on "row"  
of array "fluxes". However, this is inefficeint: Firsly, we have 5 times more 
kernel invocation overheads (the Rodinia CUDA version has only one kernel); Secondly,
because a lot of computation is common for all 5 rows, separating them loses the
opportunity to reuse data because data in cache is not persistent across different
kerenl invocations. This is not an easy problem and further discssion is needed 
with more experienced SAC developers.  

Finally, apart from transforming the arrays layout, the Rodinia verions utilise 
constant memory to store small arrays. We have NOT yet written a version WITHOUT
such constant memory optimzation. However, this should be fairly trivial. 
Not runtime comparision has been made between any versions of this benchmarks. This
will be performed later. 

All input files are in the ./input directory. Files with names fvcorr.domn.* are 
inputs to the Rodinia CUDA and OpenMP version. Files with names sac_input_* are inputs
to the SAC versions. Here * represent the size (number of rows) of the input. The
first line of each input file contains the total number of total lines in the file.
Note that currently, the input size is hardcoded in the program by a #define macro.
This means that if we want to use a different input file with different size, we
need to change the #define macro as well. The reason we do this is to ensure all
arrays in the SAC program is AKS.  

