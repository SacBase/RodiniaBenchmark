use StdIO: all;
use Array: all;
use CommandLine: all;
use Math: all;
use Benchmarking: all;

#define FLOAT

//#define FIBRE
/* Fibre doesn't work with the CUDA transfer mechs,
 * there seems to be something going wrong in how
 * the actual data pointer is passed around within
 * this application after FibreRead* has been called.
 */

#ifdef FLOAT
#define DBL float
#define TOD tof
#else
#define DBL double
#define TOD tod
#endif

#ifndef SIZE
#define SIZE 64
#endif

// is the same as used in C/CUDA implementation
DBL[.,.] create_matrix(int[] size)
{
  lamda = TOD(-0.001);

  coe_i = with {
    (. <= [i] <= .) : TOD(10) * exp(lamda * TOD(i));
  } : genarray([size], TOD(0));

  coe = with {
    (. <= [i] < [size]) : coe_i[size-1-i];
    ([size] <= [k] <= .) : coe_i[k-size+1];
  } : genarray([2*size-1], TOD(0));

  m = with {
    (. <= [i,j] <= .) : coe[size-1-i+j];
  } : genarray([size, size], TOD(-1));

  return m;
}

DBL[.,.] compute(DBL[.,.] mat)
{
#ifdef C_IMP /* C implementation */

  for( i = 0; i < SIZE; i++) {
    for (j = i; j < SIZE; j++) {
      summ = mat[i, j];
      for (k = 0; k < i; k++) {
        summ -= mat[i,k]*mat[k,j];
      }
      mat[i,j] = summ;
    }

    for (j = i+1; j < SIZE; j++) {
      summ = mat[j, i];
      for (k = 0; k < i; k++) {
        summ -= mat[j, k]*mat[k, i];
      }
      mat[j, i] = summ/mat[i, i];
    }
  }

#elif SAC1 /* SAC implementation 1 */

  for( i = 0; i < SIZE; i++) {
    mat = with {
            ([i,i] <= iv=[m,j] < [i+1,SIZE]) {
              res = with {
                      ([0] <= iv=[k] < [i]) {
                        s = mat[i,k]*mat[k,j];
                      }:s;
                    }:fold(-, mat[i,j]);
            }:res;
          }:modarray(mat);

    mat = with {
            ([i+1,i] <= iv=[j,n] < [SIZE,i+1]) {
              res = with {
                      ([0] <= iv=[k] < [i]) {
                        s = mat[j,k]*mat[k,i];
                      }:s;
                    }:fold(-, mat[j,i]);
              res = res/mat[i,i];
            }:res;
          }:modarray(mat);
  }
#else /* SAC implementation 2 */

  for( i = 0; i < SIZE-1; i++) {

    /* Compute column */
    mat = with {
            ([i+1,i] <= iv=[j,n] < [SIZE,i+1]) {
              res = mat[iv]/mat[i,i];
            }:res;
          }:modarray(mat);

    mat = with {
            ([i+1,i+1] <= iv=[m,j] < [SIZE,SIZE]) {
              res = mat[iv] - mat[m,i]*mat[i,j];
            }:res;
          }:modarray(mat);
  }

#endif
  return( mat);
}

int main()
{
  DBL[SIZE,SIZE] L, U, mat;

#ifdef FIBRE
#ifdef FLOAT
  mat = FibreScanFloatArray( );
#else
  mat = FibreScanDoubleArray( );
#endif /* FLOAT */
#else
  mat = create_matrix(SIZE);
#endif /* FIBRE */
#if 0 /* XXX */
#ifdef OUTPUT
#ifdef FIBRE
  FibrePrint( mat);
#else
  print( mat);
#endif /* FIBRE */
#endif /* OUTPUT */
#endif

  interval0 = getInterval( "LUD", 0, 1);
  start( interval0 );
  mat = compute( mat);
  end( interval0 );

  time, unit = returnResultUnit(interval0);
  printf(" %.3f %s\n", time, unit);

#ifdef OUTPUT
#ifdef FIBRE
  FibrePrint( mat);
#else
  print( mat);
#endif /* FIBRE */
  return( 0);
#else
  return( toi(mat[0,0]));
#endif /* OUTPUT */
}

